PEP: xxxx
Title: Simplify class extension
Version: $Revision$
Last-Modified: $Date$
Author: Pim Schellart, Nate Lust
Status: 
Type: 
Content-Type: text/x-rst
Created: 24-Aug-2016
Python-Version: 3.6
Post-History: 24-Aug-2016


Abstract
========

This PEP proposes the continue class syntax for extending existing classes.


Rationale
=========

Extending existing classes with new members currently requires the members
to be defined outside of class scope and then assigned to the class, as in::

  def foo(self):
    pass
  A.foo = foo
  del foo

This pattern frequently occurs when extending classes from extension module
written in other languages.

This syntax is however cumbersome and error prone for the following reasons:

  1. The name of the new member might clash with an existing name at module
     scope.
  2. The developer might forget the assignment.
  3. The developer might forget to delete the temporary, leaving it at
     module scope where it is meaningless.

Alternatives are to use inheritance, lambda or a class decorator.
Inheritance is not a good option for use with Python extension modules
(written in e.g. C / C++). The reason is that if in the other language
(say C++) the inheritance relation is A<-B, and this is exposed to Python,
we can't add functionality to A in Python by subclassing A<-A' without also
introducing B' that inherits from B and A'. Thus one change propagates all
the way up the inheritance chain.

Using lambda is not equivalent because it only allows for positional
arguments.

A class decorator (say @continue_class(MyClass) that takes methods and
attributes from the class and attaches them to the wrapped type) works,
but is cumbersome and requires a new class name to be introduced for each
extended type. Thus suffering from the same problems numbered (1) and (2) above.

This proposal adds the keyword combination "continue class" which instructs
the interpreter to add members to an existing class.

By combining existing keywords it avoids name clashes. A precedent for this
exists in "is not".

Another big advantage of the "continue class" syntax is discoverability, by
humans and tools, of extended classes.

Semantics
=========

The following two snippets are semantically identical::

  continue class A:
    def foo(self):
      pass
  
  def foo(self):
    pass
  A.foo = foo
  del foo
    

Alternatives
============

An alternative could be to allow a function definition to include a class
specifier as in::

  def A.foo(self):
    pass


Implementation
==============

Adapting Python's grammar to support the continue class keyword combination
requires...


Acceptance
==========



References
==========


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
